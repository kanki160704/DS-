# self attention 中 K、Q、V 实际意义

# 多层 attention

# 随机森林深度很深会过拟合吗？

# cross attention K、Q、V是谁的

# 多层 Transformer

# 分词，标点符号如何处理

# 如何进行数据预处理

# 线性回归 有共线性怎么办

# 机器学习的一般步骤

# WOE、IV是什么
在分类问题中，有时需要对变量进行分箱。如何确定分箱好坏？对于一个分箱，WOE_i = ln(bad_i / bad总数) - ln(good_i / good总数)。IV_i = (bad_i / bad总数 - good_i / good总数) * WOE_i.如果一个分箱坏账率高，那么IV值也会高。  

# 数据库事物四大特性
原子性：要么全部成功，要么全部回滚  
一致性：例如存钱取钱的数据库，操作前后总钱数需要不变  
隔离性：一个操作不能被别人操作干扰  
持久性：事物提交后对数据库改变是永久的  

# 几种数据库隔离性的错误与解决方法
脏读：读取了未提交的数据。张三原先余额0，存入1000，李四读取了余额为1000，张三回滚。李四脏读  
不可重复读：李四读取张三余额为0，张三存入1000并提交，李四再读余额1000.李四同一事物读取不一样值。  
幻读：与不可重复读类似，但是是前后两次数据量不一致。例如李四第一次读取1000个数据，张三添加了1000个数据并提交，李四就读到2000个数据。

读未提交，会有以上三种问题。  
读已提交（只能读取已经提交的事物），解决脏读。  
重复读：事物开始之后，别人不能对事物进行修改。(默认)  
串行：一个一个来  

判断是否可串行：前趋图  
如果操作p、q针对同一个内容，并且p早于q，并且p、q至少一个是写操作，那么 p -> q。  
如果有环，就无法串行化。  

# AUC、ROC是什么
ROC 曲线y轴为 TP / (TP + FN)，x轴为 FP / (FP + TN)  
AUC 表示 ROC 面积

# 第一类错误、第二类错误，哪个更严重，p-value是什么
第一类错误 FP，认为是positive（应该接受新假设），但是错了。  
第二类错误 FN，认为是negative，但是错了  
第一类错误严重，因为第二类错误相当于没有改变，但是第一类错误是往错误方向改变了  
p-value 指的是，更极端的情况出现的概率。如果p很小，那么就更容易拒绝原假设  

# 大数定律和中心极限定理是什么
大数定理：样本越多，样本参数值越能接近于总体的参数值。例如，去了足够多样本后，样本的均值会收敛于总体数学期望。  
中心极限定理：均值是正态分布的

# 数据库第二第三范式
第二范式：任何键不可以部分依赖于主键  
第三范式：任何非主属性不可以依赖于非主属性（消除传递依赖）

# 如何进行特征选择
前向法、反向法  
过滤法：不依赖于模型。Relief算法，适用于二分类问题。每个点x，找一个和他距离最近的并且与他分类一致的点 x_1, 找一个和他距离最近并且分类不同的点 x_2。如果要评价特征 j 在 x上的好坏，就计算 x与x_1 距离 d1， x与x_2 距离 d2，我们希望d1很小但是d2很大。用d2 - d1 代表特征j好坏，越大越好。对所有点这么做，结果相加为特征j 总体的评价  
包裹法：如果连续T次都做的没有已知最优解好，那么我们就认为已知最优解是最好的特征选择。定义好：特征在交叉验证中效果好或者在交叉验证中表现一样但是特征数量少。  
嵌入式：正则化
# 机器学习的一般方法

# InnoDB 逻辑结构
InnoDb 分为表空间(tablespace)、段(segment)、区(extent)、页(page)、行(row)、字段，每一个前者都包括若干后者。  

# InnoDB 内存结构
内存中分为 缓冲区(Buffer Pool)，更改缓冲区(Change Pool)、日志缓冲区
Buffer Pool：缓存磁盘上真实数据，增删改查时会优先检查此处，再以一定频率刷新到磁盘  
缓冲区以页为单位，底层采用链表形式管理page，并将page分为三种状态  
free page：空闲页，未被使用过  
clean page：被使用过的页，但数据未被修改过  
dirty page：被使用过的页，数据被修改过，即与磁盘不一致  

Change Buffer: 针对非唯一二级索引页(对唯一或者主键索引不会操作这里)，在增删改操作中，如果这些page没有在Buffer Pool中，不会直接操作磁盘，而是会记录在 Change Buffer中，未来数据被读取时，再将数据合并恢复到Buffer Pool中，再写入磁盘  

日志缓冲区：负责保存 redo、undo两个日志

# 索引分类
主键索引  
唯一索引  
联合索引  
哈希索引(如果等值查询，建议使用哈希索引。范围查找，不建议范围查找。也有哈希碰撞的问题)  

# 索引优缺点  
优点：提升查询效率，如果列本身排序适合用索引  
劣势：增删改不友好，占用磁盘空间

# 聚簇索引与非聚簇索引
聚簇：索引和数据放在一起存放(innodb默认)  
非聚簇：索引和数据分开  

# 哪些字段适合成为索引
经常使用where后查询的  
字段识别度高(例如性别就不适合，因为性别只有两种)  

# 如何避免索引失效
全值匹配(select语句中where要筛选所有的索引列)  
最左前缀法则：查询时where后筛选顺序需要与定义索引顺序一致  
不要使用范围查询  

# SQL 优化
Insert 优化：  
批量插入(每一次Insert都需要和数据库交互，这么做会更耗时)  
手动提交事物  
主键顺序插入(避免页分裂)  
如果数据太多，不建议使用insert，可以使用load命令  

主键优化：  
降低主键长度  
不要使用 uuid或者身份证号等作为主键，因为会导致页分裂  
尽量不要修改主键  

order by 优化，尽量选择索引排序  
group by优化，尽量使用索引，并且满足最左前缀法则  
limit优化，
select 优化，select 选择的内容尽量选择索引字段(覆盖索引)
